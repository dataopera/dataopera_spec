FORMAT: 1A
HOST: https://man-api.herokuapp.com/

# DTO - DataMea 

DataMea é uma plataforma complexa de interoperabilidade que contempla as fases de coleta, armazenamento, visualização dos dados clínicos do paciente e disponibilização de informações anonimizadas da base de dados com uso de IA.  

## Dados Cadastrais do Paciente 
O Cabeçalho do DataMea traz informações de identificação do paciente, onde foi trabalhado no método MPI - Master Patient Index, fazendo com que não haja duplicação de indivíduos e as informações sejam pertinentes a um único paciente. 

- Descrição Detalhada das Informações do Paciente no Cabeçalho DataMea: 
#Nome Completo
- Descrição: Identificação oficial do paciente, composta por nome, sobrenome e patronímico (se houver).

- Importância: Essencial para a correta identificação do paciente em registros, prontuários e outros documentos médicos.

#Nome Social
- Descrição: Nome pelo qual o paciente prefere ser chamado, podendo divergir do nome completo.

- Importância: Demonstra respeito à individualidade e identidade do paciente, promovendo uma comunicação mais humanizada.

#Tipo Sanguíneo
- Descrição: Classificação do sangue do paciente, indicando os antígenos presentes na superfície dos glóbulos vermelhos.

- Importância: Fundamental em casos de transfusões de sangue, transplantes e outras intervenções médicas que envolvam sangue.

#Idade
- Descrição: Idade cronológica do paciente, calculada a partir da data de nascimento.

- Importância: Auxilia na avaliação clínica, diagnóstico e tratamento de doenças, considerando as características e necessidades específicas de cada faixa etária.

#RG
- Descrição: Número de Registro Geral de Identidade, documento oficial de identificação civil no Brasil.

-Importância: Permite a verificação da identidade do paciente em diversos contextos, como consultas médicas, compras e abertura de contas.

#Religião
- Descrição: Crença religiosa professada pelo paciente, que pode influenciar seus valores, crenças e práticas.

- Importância: Permite que o profissional de saúde compreenda melhor o paciente e suas perspectivas de vida, possibilitando um atendimento mais holístico e sensível.

#Sexo
- Descrição: Sexo biológico do paciente, determinado por características cromossômicas, anatômicas e fisiológicas.

- Importância: Fundamental para o diagnóstico, tratamento e acompanhamento de diversas doenças, além de influenciar na escolha de medicamentos e procedimentos médicos.

#CPF
- Descrição: Número do Cadastro de Pessoa Física (CPF), documento oficial de identificação fiscal no Brasil.

- Importância: Permite a identificação do paciente em diversos contextos, como consultas médicas, compras e declarações fiscais.

#Escolaridade
- Descrição: Nível de escolaridade do paciente, que pode influenciar na compreensão de informações e na adesão ao tratamento.

- Importância: Permite que o profissional de saúde adapte a comunicação e o plano de cuidados às necessidades e características do paciente.

#Raça/Cor
- Descrição: Autodeclaração do paciente sobre sua raça e cor, elementos que compõem sua identidade étnico-racial.

- Importância: Permite que o profissional de saúde compreenda as vivências e necessidades do paciente em um contexto social marcado por desigualdades raciais, promovendo um atendimento mais equânime e justo.

![Texto Alternativo](https://github.com/dataopera/dataopera_spec/blob/master/images/datamea/cabecalho.png?raw=true)

##Sumário
O Sumário é uma apresentação de dados do paciente de forma organizadas em Cards específicos. Cada dado apresentado faz parte de um Conjunto Mínimo de Dados, também denominado como CMD, que sua organização definiu com relevante interoperabilizar com outras instituições de saúde.  Vale apresentar que as informações são apresentadas de forma agrupada e orientada de forma cronológica. 

Descrição dos campos

- PRONTO ATENDIMENTO: Este campo mostra o número de vezes que o paciente foi atendido no pronto atendimento.

- AMBULATÓRIO E OUTROS: Este campo é um recurso importante para o acompanhamento do histórico médico do paciente e as tomadas de decisões sobre o cuidado da saúde. 

- SADT: Este campo mostra o número de vezes que o paciente foi atendido pelo Serviço de Atendimento Domiciliar (SADT).

- INTERNAÇÃO: Este campo, é possível visualizar o número que o paciente teve internações em seu histórico.

- REGULAÇÃO: Este campo mostra o número de vezes que o paciente foi regulado para internação hospitalar. 

- PROCEDIMENTOS: Este campo mostra o número de procedimentos que foram realizados para o paciente.

![Texto Alternativo](https://github.com/dataopera/dataopera_spec/blob/master/images/datamea/sumario.png?raw=true)

##Linha do Tempo
A Linha do Tempo apresenta ao profissional assistente dados diferentes, mas pertinente a um atendimento específico. A navegar na linha do tempo, você irá ver todos os atendimentos interoperabilizados do paciente em blocos distintos, agrupando todas as informações de um atendimento. 

Descrição dos Campos:

- Data e Hora: A data e hora do evento são cruciais para acompanhar a progressão do atendimento do paciente e identificar possíveis atrasos ou gargalos no processo.

- Título: O título do evento fornece uma visão geral rápida do que aconteceu, facilitando a consulta da linha do tempo.

- Descrição: A descrição do evento fornece detalhes importantes sobre o que aconteceu, como os sintomas do paciente, os procedimentos realizados e os resultados obtidos.

- Tipo de Evento: O tipo de evento permite categorizar os eventos e facilitar a análise de dados, como a quantidade de consultas realizadas ou a frequência de exames específicos.

- Local: O local do evento pode ser útil para identificar em qual setor do hospital o paciente foi atendido.

- Profissional: O profissional que atendeu o paciente pode ser relevante para acompanhar o histórico do atendimento e identificar os responsáveis por cada etapa.

- Exames Solicitados: A lista de exames solicitados fornece informações sobre os exames que o paciente precisa realizar para o diagnóstico e tratamento de sua condição.

![Texto Alternativo](https://github.com/dataopera/dataopera_spec/blob/master/images/datamea/LinhadoTempo.png?raw=true)

##Histórico do Paciente
Se estiver aparecendo para você o Histórico do Paciente, sua organização fez a aquisição do produto DataHAL. Este histórico vinculado ao Sumário DataMea é uma sumarização da vida clínica registrada do paciente, apresentada de forma mais rápida e em linguagem natural por meio de Inteligência Artificial. 

Descrição dos Campos: 

- Informações demográficas: Nome do paciente, data de nascimento, sexo, endereço, etc.

- Histórico médico: Doenças, cirurgias, alergias e medicamentos passados do paciente.

- Histórico familiar: Antecedentes médicos da família do paciente, como histórico de doenças cardíacas, câncer ou diabetes.

- Histórico social: Hábitos de vida do paciente, como tabagismo, consumo de álcool e uso de drogas.

- Medicações atuais: Lista de todos os medicamentos que o paciente está tomando no momento.

- Alergias: Lista de todas as substâncias às quais o paciente é alérgico.

- Imunizações: Lista de todas as imunizações que o paciente recebeu.

- Internizações: Lista de todas as vezes que o paciente foi internado no hospital.

- Cirurgias: Lista de todas as cirurgias que o paciente realizou.

- Procedimentos: Lista de todos os procedimentos que o paciente realizou, como raios-X, tomografias computadorizadas e ressonâncias magnéticas.

- Resultados laboratoriais e Imagens: Lista de todos os resultados laboratoriais e de imagens que o paciente obteve.

![Texto Alternativo](https://github.com/dataopera/dataopera_spec/blob/master/images/datamea/HistoricodoPaciente.png?raw=true)

##DataHal
O Campo CHAT, sigla para Contexto Histórico de Atendimento Transcrito, é uma ferramenta inovadora que auxilia profissionais da saúde na tomada de decisões mais precisas e eficientes. Através do Campo CHAT, é possível realizar perguntas sobre o histórico médico de um paciente e obter respostas instantâneas baseadas em seus registros eletrônicos de saúde (prontuários eletrônicos).

**Como funciona o Campo CHAT?**

O Campo CHAT funciona por meio da análise de inteligência artificial (IA) que processa e organiza as informações contidas no prontuário eletrônico do paciente. Ao realizar uma pergunta no Campo CHAT, a IA busca por termos relevantes em todo o histórico do paciente, como diagnósticos, medicamentos, procedimentos, alergias, consultas anteriores, entre outros.

**Quais são os benefícios do Campo CHAT?**

- O Campo CHAT oferece diversos benefícios para profissionais da saúde, como:

- Maior agilidade e eficiência no atendimento: O Campo CHAT permite que os profissionais da saúde obtenham informações relevantes sobre o histórico do paciente de forma rápida e fácil, sem a necessidade de consultar manualmente o prontuário eletrônico. Isso otimiza o tempo de atendimento e permite que os profissionais se concentrem mais no paciente.
- Melhora na qualidade do cuidado: O acesso rápido e preciso às informações do histórico do paciente permite que os profissionais da saúde tomem decisões mais bem informadas sobre o diagnóstico, tratamento e acompanhamento do paciente. Isso contribui para a melhora na qualidade do cuidado e na segurança do paciente.
- Redução de erros médicos: O Campo CHAT pode ajudar a reduzir erros médicos ao fornecer aos profissionais da saúde uma visão completa do histórico do paciente, incluindo alergias, medicamentos em uso e interações medicamentosas.
- Maior satisfação do paciente: O Campo CHAT permite que os profissionais da saúde ofereçam um atendimento mais personalizado e centrado no paciente, o que pode aumentar a satisfação do paciente com o cuidado recebido.

Em resumo, o Campo CHAT é uma ferramenta valiosa que pode auxiliar profissionais da saúde na tomada de decisões mais precisas e eficientes, na melhoria da qualidade do cuidado e na redução de erros médicos. Além disso, o Campo CHAT pode contribuir para aumentar a satisfação do paciente com o atendimento recebido.

- Observação: É importante ressaltar que o Campo CHAT é uma ferramenta complementar e não deve substituir a avaliação clínica do profissional da saúde.

**Lembrando que o DataHal é um produto comercializado à parte que realiza integração com DataMea, caso seja contratado pela sua empresa essa função estará disponível para utilização.**

![Texto Alternativo](https://github.com/dataopera/dataopera_spec/blob/master/images/datamea/DataHal.png?raw=true)

##Últimos Atendimentos:

Este card apresenta de forma resumida informações primárias dos tipos de atendimentos que o paciente foi submetido nesta ou em outras instituições de saúde. De forma cronológica é apresentado informações do profissional, data do atendimento, tipo de atendimento, tipo de Alta (saída da instituição) e se houve registro de acidente. 

Descrição dos Campos: 
- Profissional responsável: O nome do médico ou outro profissional que o atendeu.

- Especialidade : CBO do médico que realizou o atendimento ao paciente.

- Data de Entrada : A data em que o atendimento foi registrado.

- Data de Saída : Data da alta do paciente.

- Tipo de atendimento: A especialidade médica ou o tipo de procedimento realizado (consulta, exame, internação, etc.).

- Modalidade: Tipo de modalidade de atendimento prestada ao paciente (SADT, Ambulatório, Virtual, etc.)

- Tipo de Alta: A forma como você saiu da instituição após o atendimento (alta médica, alta hospitalar, etc.).

- Tipo de acidente: Se o atendimento foi relacionado a um acidente, essa informação será indicada no card.

![Texto Alternativo](https://github.com/dataopera/dataopera_spec/blob/master/images/datamea/UltimosAtendimentos.png?raw=true)

##Agendamentos Futuros: 

O Card Agendamentos Futuros: Com finalidade de saber se existe uma programação futura para o paciente, tais como terapias ou contatos assistenciais com especialistas, o Card agendamento Futuros apresenta dados que demonstram futuras intervenções clínicas para o paciente em atendimento.

Descrição dos Campos: 

- Especialidade: CBO do médico que realizouo paciente agendou o atendimento. 

- Tipo: Procedimento que será realizado para o paciente (consulta, exames, etc.)

- Data e Hora: Data e Hora do agendamento realizado pelo paciente. 

![Texto Alternativo](https://github.com/dataopera/dataopera_spec/blob/master/images/datamea/AgendamentosFuturos.png?raw=true)

##Alergias e Reações Adversas: 

O Card Alergias e Reações Adversas, tem por finalidade de mostrar registros de reações a substâncias e os tipos de manifestações que este paciente seja sensível, fazendo com que o profissional tenha meios de avaliações e definições de condutas mais seguras. 

Descrição dos Campos: 

- Substância: Tipos de alergias manifestadas pelo paciente (Alimentares, respiratórias, medicamentosas, picadas de insetos e dermatite de contato)

- Manifestações: Sintomas apresentados no paciente devido aos tipos de alergias manifestadas no corpo humano.

![Texto Alternativo](https://github.com/dataopera/dataopera_spec/blob/master/images/datamea/Alergias.png?raw=true)

##Imunizações: 

O Card Imunizações reflete em ordem cronológicas registros de vacinas imunizantes registrados para o paciente. 

Descrição dos Campos:

- Descrição: Informações das vacinas tomadas pelo paciente.

- Dose: Quantidade de doses de vacinas aplicadas no paciente. 

- Data: Data que foi realizada a aplicação da vacina no paciente. 

![Texto Alternativo](https://github.com/dataopera/dataopera_spec/blob/master/images/datamea/Imunizacoes.png?raw=true)

##Histórico de Doenças Familiares: 

O Card Histórico de Doenças familiares: apresenta dados informados pelo próprio paciente ou por responsáveis nos atendimentos de dados de doenças na família que direciona a avaliação de possibilidade de desenvolvimento de doenças futuras devido a histórico familiar ou condições hereditárias. 

Descrição dos Campos: 

- Data e Hora: Data e horário que o paciente relata ao médico sobre algum histório de doença familiar.

- Descrição: Informações citadas pelo paciente ao médico onde é informado algum histórico de doença na família.

![Texto Alternativo](https://github.com/dataopera/dataopera_spec/blob/master/images/datamea/HistoricoFamiliar.png?raw=true)

##Dados de Históricos Pessoal:

O Card Dados do Histórico Pessoal: são dados informados pelos pacientes em contatos assistenciais neste ou em outras organizações de saúde, relatando seu histórico de vida como hábitos, vícios, doenças e tratamentos. 

Funciona como um repositório centralizado de informações sobre a saúde do paciente. Ele reúne dados coletados durante consultas médicas, internações, exames e outros contatos com o sistema de saúde, tanto na organização atual quanto em outras instituições.

Descrição dos Campos: 

- Data e Hora: Data e horário que o paciente relata ao médico sobre algum histório pessoal de doença.

- Descrição: Informações citadas pelo paciente ao médico onde é informado algum histórico de doença pessoal. 

![Texto Alternativo](https://github.com/dataopera/dataopera_spec/blob/master/images/datamea/DadosHistóricoPessoal.png?raw=true)


















## Links

Teste [README.md](https://github.com/Nebo15/man.api/blob/master/LICENSE.md) 

## Processos

![UI Demo](https://github.com/Nebo15/man.web/raw/master/docs/images/ui-animated.gif)

## Performance

We encourage you to perform your own tests, because synthetic results are far from real life situation. We provide them only as starting point in understanding Man's performance.

### Test environment

* Environments

### Results

| **Metric**/**Template Syntax**                          | **Mustache** | **Markdown** | **Mustache with PDF format** | **Mustache with PDF format** **and PDF cache enabled** |
| ------------------------------------------------------- | ------------ | ------------ | ------------- | ------------- |
| Concurrency Level                                       | 50           | 50           | 50            | 50 |
| Time taken for tests                                    | 8.412 sec    | 8.142 sec    | 442.214 sec   | 11.255 sec |
| Complete requests                                       | 10000        | 10000        | 10000         | 10000 |
| Failed requests                                         | 0            | 0            | 0             | 0 |
| Requests per second [#/sec] (mean)                      | **1188.84**  | **1228.25**  | **22.61**     | **888.52** |
| Time per request                                        | 42.058 [ms]  | 40.708 [ms]  | 2211.070 [ms] | 56.274 [ms] |
| Time per request (mean, across all concurrent requests) | 0.841 [ms]   | 0.814 [ms]   | 44.221 [ms]   | 1.125 [ms] |

Full console output is available in [`pertest.md`](https://github.com/Nebo15/man.api/blob/master/docs/perftest.md).

### PDF Output Cache

Since generating PDF is slow, Man allows to cache `wkhtmltopdf` output.

This cache can be used when you have less than 1000 of different templates variations (eg. markdown templates, or mustache templates but all variables are continuous or enums). To enable it simply set `CACHE_PDF_OUTPUT=true` in your environment.

Enabling cache when output variety is high will hurt your performance (cache will always be cold, since it's based on HTML checksum) and may lead to node crashes (ETC table may overflow).

## Setup Guide

### Docker

Easiest way to deploy Man is to use docker containers.
We constantly are releasing pre-built versions that will reduce time to deploy:

- [Back-End Docker container](https://hub.docker.com/r/nebo15/man_api/) (~239 MB);
- [PostgreSQL Docker container](https://hub.docker.com/r/nebo15/alpine-postgre/) (~16 MB);
- [UI Docker container](https://hub.docker.com/r/nebo15/man-web/) (~108 MB).

They are built on top of Alpine Linux, to reduce container size and memory consumption.

### Heroku

Template allows to deploy Man to Heroku just in minute (and use it for free within Heroku tiers):

[![Deploy](https://www.herokucdn.com/deploy/button.svg)](https://heroku.com/deploy?template=https://github.com/nebo15/man.api)

## Common errors

> I'm getting HTTP 400 (Mailformed JSON) responses.

Make sure that JSON is valid with [JSON Formatter](jsonformatter.curiousconcept.com).
If request is valid, probably your request body structure is invalid. In most cases you forgot to send root `template` object when updating Templates.

> I'm getting HTTP 415 responses.

You MUST always set `Content-Type: application/json` header when requesting Man's API.

## Templates [/templates]

### Search for a Template [GET /templates{?limit,starting_after,ending_before,labels,title}]

+ Parameters
    + labels: `label-name1,label-name2` (string, optional) - Label names to filter Templates list.
    + limit: 20 (number, optional) - A limit on the number of objects to be returned, between 1 and 100. Default: 50.
    + starting_after: 56c31536a60ad644060041af (string, optional) - A cursor to fetch next page. Taken from collection response.
    + ending_before: 56c31536a60ad644060041aa (string, optional) - A cursor to fetch previous page. Taken from collection response.
    + title: Signup (string, optional) - Substring search for a title.

+ Response 200 (application/json)
    + Attributes (Response_Collection)
        + data (array[Template_Response], fixed-type)

### Create Template [POST]

+ Request (application/json)
    + Attributes (object)
        + template (Template)

+ Response 201 (application/json)
    + Headers
    
            Location: /templates/58e2278a84092e61700041a7
            
    + Attributes (Response_OK)
        + meta (Response__Meta)
            + code: 201 (number)
        + data (Template_Response)

### Get Template by ID [GET /templates/{id}]

+ Parameters
    + id: 58e2278a84092e61700041a7 (string) - Template ID

+ Response 200 (application/json)
    + Attributes (Response_OK)
        + data (Template_Response)

### Replace Template [PUT /templates/{id}]

+ Parameters
    + id: 58e2278a84092e61700041a7 (string) - Template ID

+ Request (application/json)
    + Attributes (object)
        + template (Template)

+ Response 200 (application/json)
    + Attributes (Response_OK)
        + data (Template_Response)

### Update Template [PATCH /templates/{id}]

+ Parameters
    + id: 58e2278a84092e61700041a7 (string) - Template ID

+ Request (application/json)
    + Attributes (object)
        + template (object)
            + body: `<h1>{{user_name}}</h1>` (string, optional)

+ Response 200 (application/json)
    + Attributes (Response_OK)
        + data (Template_Response)
            + body: `<h1>{{user_name}}</h1>` (string, required)

### Delete Template [DELETE /templates/{id}]

+ Parameters
    + id: 58e2278a84092e61700041a7 (string) - Template ID

+ Request (application/json)
+ Response 204 (application/json)

### Render Template [POST /templates/{id}/actions/render]

#### Localization

You can pass `Accept-Language: <localization>` header or `localization` request attribute.

In case both fields are specified, HTTP header will be preffered.

When there is only one locale set for a template, localization attribute is optional and the onlymost list element will be counted as default.

#### Available variables

Template can use any variables from request attributes as global scoped objects `{{var_name}}` and all available localization fields within `l10n` object `{{l10n.localized_key}}`.

#### Validation

Rendering request is validated by JSON Schema that is set in Template.

#### Output Format

Output format is controlled by `Accept: <format>` header.

**Supported formats:**

| `Accept` (format)     | Response `Content-Type`           | Description |
| --------------------- | --------------------------------- | ----------- |
| `text/html` (default) | `text/html; charset=utf-8`        | Raw HTML Page. |
| `application/json`    | `application/json; charset=utf-8` | JSON object with `body` and `params` fields: `{"body":"<h1>Hello Alex, in en_US</h1>"}` |
| `application/pdf`     | `application/pdf`                 | PDF document rendered from HTML. |

**Notice.** You can use `params` field from JSON response to localize fields that should be used elsewhere, even if template does not contain matched fields. For example, you can localize email subjects in this way.

**Warning!** Format is applied only when there was no errors during rendering, otherwise - response will be always in json format with `Content-Type: application/json`.

+ Parameters
    + id: 58e2278a84092e61700041a7 (string) - Template ID

+ Request (application/json)
    + Headers

            Accept: text/html
            Accept-Language: en-US

    + Attributes (object)
        + locale: en_US (string, optional) - Locale of template that should be rendered. Required when `Accept-Language` header is not set.
        + format: `text/html` (enum, optional) - Format of output.
            - `text/html` (string) - Render HTML page.
            - `application/json` (string) - Render HTML page and returin it in JSON object.
            - `application/pdf` (string) - Render PDF from HTML template.
            - Default: text/html
        + user_name: Alex (string) - Template data that should be used by rendering engine.

+ Response 200 (text/html)
    + Body

            <h1>Hello Alex, in en_US</h1>

+ Response 404 (application/json)
    + Attributes (`Response_Error`)
        + meta
            + code: 404
        + error
            + type (enum, required)
                - `locale_not_found` (string) - Specified locale is not set for a template.
                - `not_found` (string) - Template not found.

+ Response 422 (application/json)
    + Attributes (`Response__Error_ValidationFailed`)

## Labels Collection [/labels]

### Get all defined labels [GET]

+ Request (application/json)
+ Response 200 (application/json)
    + Attributes (Response_OK)
        + data (array[string], fixed-type)
            + `group/emails` (string, required)
            + `action/signup` (string, required)

# Data Structures
## Responses
### `Response_Collection`
+ meta (Response__Meta, fixed-type)
+ data (array[], fixed-type)
+ paging (Response__Pagination, fixed-type)

### `Response_OK`
+ meta (Response__Meta, fixed-type)
+ data (object, fixed-type)

### `Response_Error`
+ meta (Response__Meta, fixed-type)
    + code: 400 (number)
+ error (Response__Error, fixed-type)

### `Response__Meta`
+ code: 200 (number) - HTTP response code.
+ url: http://example.com/resource (string) - URL to requested resource.
+ type (enum) - Type of data that is located in `data` attribute.
    - object (string) - `data` attribute is a JSON object.
    - list (string) - `data` attribute is a list.
+ code: 200 (number) - HTTP response code.
+ `idempotency_key`: `idemp-ssjssdjoa8308u0us0` (string, optional) - [Idempotency key](http://docs.apimanifest.apiary.io/#introduction/optional-features/idempotent-requests). Send it trough `X-Idempotency-Key` header.
+ `request_id`: `req-adasdoijasdojsda` (string) - [Request ID](http://docs.apimanifest.apiary.io/#introduction/interacting-with-api/request-id). Send it with `X-Request-ID` header.

### `Response__Error`
+ type: type_atom (string) - Atom that represents error type.
+ message: Error description (string) - Human-readable error message. This is for developers, not end-users.

### `Response__Error_DuplicateEntity`
+ type: `object_already_exists` (string) - Atom that represents error type.
+ message: This API already exists (string) - Human-readable error message. This is for developers, not end-users.

### `Response__Error_ValidationFailed`
+ type: validation_failed (string) - type of an error.
+ message: Validation failed. You can find validators description at our API Manifest: http://docs.apimanifest.apiary.io/#introduction/interacting-with-api/errors. (string)
+ invalid (array)
    + `entry_type`: `json_data_proprty` (string) - Type of error.
    + entry: $.cvv (string) - JSON Path to an invalid property.
    + rules (array)
        + rule: required (string) - String constant that represents validation rule type. List of all types can be found in [API Manifest](http://docs.apimanifest.apiary.io/#introduction/interacting-with-api/errors).
        + params (array) - Validation Parameters.

### `Response__Pagination`
+ limit: 20 (number) - A limit on the number of objects to be returned, between 1 and 100. Default: 50.
+ cursors (object)
    + `starting_after`: 56c31536a60ad644060041af (string) - A cursor for use in pagination. An object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    + `ending_before`: 56c31536a60ad644060041aa (string) - A cursor for use in pagination. An object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
+ size: 1000 (number) - Total number of objects in collection.
+ has_more: false (boolean) - Is this collection have more data to load in the same style as last request loaded it.

## Templates
### Template
+ title: `Sign-Up Email` (string, required) - Template UI title with max length 255 characters.
+ description: `Email that is sent on signup process` (string, optional) - Template UI description with max length 510 characters.
+ syntax: `mustache` (enum, optional) - Syntax processor for a template
    + `mustache`
    + `markdown`
+ body: `<h1>{{l10n.hello}} {{user_name}}, in {{locale}}</h1>` (string, required) - Template that should be rendered with `syntax` processor.
+ locales (array[Template__Locale], optional) - Locale variables that can be used for multilangual templates.
+ labels (array[string], optional) - List of strings. Max length for element is 100 characters.
    + `group/emails` (string)
    + `action/signup` (string)
    + `other_tag` (string)
+ validation_schema (object, optional) - JSON Schema to validate requests to the template.

### `Template_Response` (Template)
+ id: 58e2278a84092e61700041a7 (string, optional)
+ created_at: `2017-04-20T19:14:13Z` (string, required) - ISO 8601 date and time in UTC timezone.
+ updated_at: `2017-04-20T19:14:13Z` (string, required) - ISO 8601 date and time in UTC timezone.

### `Template__Locale`
+ code: en_US (string, required) - Locale for defined template
+ params (object, required) - Localized attributrs.
    + hello: Hello (string, optional) - Localized variable.